/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-static-node-gyp-build",
factory: function (require) {
var plugin=(()=>{var _=Object.create;var w=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var Z=Object.getOwnPropertyNames;var q=Object.getPrototypeOf,G=Object.prototype.hasOwnProperty;var p=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+r+'" is not supported')});var V=(r,e)=>{for(var t in e)w(r,t,{get:e[t],enumerable:!0})},R=(r,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of Z(e))!G.call(r,o)&&o!==t&&w(r,o,{get:()=>e[o],enumerable:!(i=W(e,o))||i.enumerable});return r};var M=(r,e,t)=>(t=r!=null?_(q(r)):{},R(e||!r||!r.__esModule?w(t,"default",{value:r,enumerable:!0}):t,r)),J=r=>R(w({},"__esModule",{value:!0}),r);var de={};V(de,{default:()=>me});var c=p("@yarnpkg/fslib"),d=p("@yarnpkg/core"),O=p("@yarnpkg/libzip"),y=class{supports(e,t){return!!e.reference.startsWith("static-prebuild:")}getLocalPath(e,t){return null}async fetch(e,t){let i=new c.NodeFS,{zipPackage:o}=await this.fetchPrebuild(e,t),n=o.getRealPath();await c.xfs.chmodPromise(n,420);let s=`${t.cache.cacheKey}/${e.locatorHash}`,a=t.cache.getLocatorPath(e,s);if(t.cache.markedFiles.add(a),!a)throw new Error("Assertion failed: Expected the cache path to be available");await c.xfs.mkdirpPromise(c.ppath.dirname(a)),await c.xfs.movePromise(n,a);let u,f=()=>new O.ZipFS(a,{baseFs:i,readOnly:!0}),g=new c.LazyFS(()=>d.miscUtils.prettifySyncErrors(()=>u=f(),B=>`Failed to open the cache entry for ${d.structUtils.prettyLocator(t.project.configuration,e)}: ${B}`),c.ppath);return{packageFs:new c.AliasFS(a,{baseFs:g,pathUtils:c.ppath}),releaseFs:()=>{u?.discardAndClose()},prefixPath:d.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(e,t),checksum:s}}async fetchPrebuild(e,t){let i=await c.xfs.mktempPromise(),o=c.ppath.join(i,"prebuilt.zip"),n=d.structUtils.getIdentVendorPath(e),s=new O.ZipFS(o,{create:!0});await s.mkdirpPromise(n);let a=new c.CwdFS(n,{baseFs:s});await a.writeJsonPromise("package.json",{name:d.structUtils.slugifyLocator(e),main:"./index.js",preferUnplugged:!0});let u=`// This will be replaced at the end of the build step
    // locatorHash: ${e.locatorHash}
    `;return await a.writeFilePromise("index.js",u),s.saveAndClose(),{zipPackage:s}}};var P=p("@yarnpkg/core"),v=class{supportsDescriptor(e,t){return!!e.range.startsWith("static-prebuild:")}supportsLocator(e,t){return!!e.reference.startsWith("static-prebuild:")}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,i){return e}getResolutionDependencies(e,t){return{}}async getCandidates(e,t,i){if(!i.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");return[P.structUtils.makeLocator(P.structUtils.parseIdent("node-gyp-build"),e.range)]}async getSatisfying(e,t,i,o){let[n]=await this.getCandidates(e,t,o);return{locators:i.filter(s=>s.locatorHash===n.locatorHash),sorted:!1}}async resolve(e,t){return{...e,version:"*",languageName:t.project.configuration.get("defaultLanguageName"),linkType:P.LinkType.HARD,dependencies:new Map,peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:new Map}}};var b=p("@yarnpkg/core");var $=p("@yarnpkg/fslib"),l=p("@yarnpkg/core"),j=p("stream"),S=p("@yarnpkg/libzip"),h=p("@yarnpkg/fslib"),U=p("@yarnpkg/libzip");var F=p("@yarnpkg/fslib"),k=M(p("os")),x=M(p("fs")),K=process.config&&process.config.variables||{},Q=process.versions.modules,N=oe()?"electron":"node",E=process.env.npm_config_arch||k.arch(),I=process.env.npm_config_platform||k.platform(),X=process.env.LIBC||(se(I)?"musl":"glibc"),Y=process.env.ARM_VERSION||(E==="arm64"?"8":K.arm_version)||"",ee=(process.versions.uv||"").split(".")[0];function te(r){let e=r.split("."),t=e.pop(),i={file:r,specificity:0};if(t==="node"){for(let o=0;o<e.length;o++){let n=e[o];if(n==="node"||n==="electron"||n==="node-webkit")i.runtime=n;else if(n==="napi")i.napi=!0;else if(n.slice(0,3)==="abi")i.abi=n.slice(3);else if(n.slice(0,2)==="uv")i.uv=n.slice(2);else if(n.slice(0,4)==="armv")i.armv=n.slice(4);else if(n==="glibc"||n==="musl")i.libc=n;else continue;i.specificity++}return i}}function re(r,e){return function(t){return!(t==null||t.runtime!==r&&!ie(t)||t.abi!==e&&!t.napi||t.uv&&t.uv!==ee||t.armv&&t.armv!==Y||t.libc&&t.libc!==X)}}function ie(r){return r.runtime==="node"&&r.napi}function ne(r){return function(e,t){return e.runtime!==t.runtime?e.runtime===r?-1:1:e.abi!==t.abi?e.abi?-1:1:e.specificity!==t.specificity?e.specificity>t.specificity?-1:1:0}}function oe(){return process.versions&&process.versions.electron||process.env.ELECTRON_RUN_AS_NODE?!0:typeof window<"u"&&window.process&&window.process.type==="renderer"}function se(r){return r==="linux"&&x.existsSync("/etc/alpine-release")}async function T(r,e){let o=(await e.readdirPromise(F.ppath.join(r,"prebuilds"))).map(ce).filter(f=>f).filter(ae(I,E)).sort(le)[0];if(!o)return null;let n=F.ppath.join(r,"prebuilds",o.name),u=(await e.readdirPromise(n)).map(te).filter(re(N,Q)).sort(ne(N))[0];return u?F.ppath.join(n,u.file):null}function ae(r,e){return function(t){return t==null||t.platform!==r?!1:t.architectures.includes(e)}}function ce(r){let e=r.split("-");if(e.length!==2)return null;let t=e[0],i=e[1].split("+");return!t||!i.length||!i.every(Boolean)?null:{name:r,platform:t,architectures:i}}function le(r,e){return r.architectures.length-e.architectures.length}async function C(r,e,t,i){let{packageLocation:o,packageFs:n}=await A(e,t),{packageLocation:s,packageFs:a}=await A(r,t),u=await T(s,a);u===null&&i.report.reportError(l.MessageName.UNNAMED,`Unable to locate prebuild for ${l.structUtils.stringifyLocator(r)}`);let f=h.ppath.relative(s,u),g=h.ppath.basename(f),L=await a.readFilePromise(f);if(L===null)throw new l.ReportError(l.MessageName.UNNAMED,`Was unable to find node file in prebuild package for "${l.structUtils.stringifyIdent(r)}"`);await n.writeJsonPromise(h.ppath.join(o,"package.json"),{name:l.structUtils.slugifyLocator(e),main:"./index.js",preferUnplugged:!0});let D=`// Automatically generated bindings file for ${l.structUtils.stringifyIdent(r)}
// Package version: ${r.version}
// Bindings taken from: ${f}

const staticRequire = require("./${g}");
module.exports = (fileLookingFor) => {
  return staticRequire;
};
`;await n.writeFilePromise(h.ppath.join(o,"index.js"),D),await n.writeFilePromise(h.ppath.join(o,g),L),i.report.reportInfo(l.MessageName.UNNAMED,`Installed prebuild for ${l.structUtils.stringifyLocator(r)} from ${f}`)}async function A(r,e){let t=e.storedPackages.get(r.locatorHash);if(!t)throw new Error(`Package for ${l.structUtils.prettyLocator(e.configuration,r)} not found in the project`);return await U.ZipOpenFS.openPromise(async i=>{let o=e.configuration,n=e.configuration.getLinkers(),s={project:e,report:new l.StreamReport({stdout:new j.PassThrough,configuration:o})},a=n.find(g=>g.supportsPackage(t,s));if(!a)throw new Error(`The package ${l.structUtils.prettyLocator(e.configuration,t)} isn't supported by any of the available linkers`);let u=await a.findPackageLocation(t,s),f=new $.CwdFS(u,{baseFs:i});return{packageLocation:u,packageFs:f}},{libzip:await(0,S.getLibzipPromise)()})}function pe(r){return r.name==="fsevents"&&process.platform!=="darwin"?!1:r.name==="node-gyp-build"&&r.scope===null}async function ue(r,e){let t=new Map;for(let i of r.storedPackages.values())pe(i)&&t.set(b.structUtils.convertLocatorToDescriptor(i).descriptorHash,i);for(let i of r.storedPackages.values())for(let[o,n]of i.dependencies){let s=t.get(n.descriptorHash);if(s){try{await C(i,s,r,e)}catch(a){e.report.reportInfo(b.MessageName.UNNAMED,`Couldn't mutate node-gyp-build for ${b.structUtils.stringifyLocator(i)}`),console.error(a)}break}}}async function H(r,e){await e.report.startTimerPromise("Native dependency resolution",async()=>{await ue(r,e)})}var m=p("@yarnpkg/core"),z=async(r,e,t,i,o)=>{if(r.name==="node-gyp-build"&&r.scope===null){let n=m.structUtils.makeDescriptor(r,m.structUtils.makeRange({protocol:"static-prebuild:",source:m.structUtils.stringifyDescriptor(r),selector:`node-gyp-build<${m.structUtils.stringifyLocator(t)}>`,params:null}));return o.resolveOptions.report.reportInfo(m.MessageName.UNNAMED,`Found a node-gyp-build dependency in ${m.structUtils.stringifyLocator(t)}, re-routing to prebuild under name ${n.name}`),n}return r};var fe={hooks:{reduceDependency:z,afterAllInstalled:H},fetchers:[y],resolvers:[v]},me=fe;return J(de);})();
return plugin;
}
};
